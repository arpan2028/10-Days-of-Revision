class Solution(object):
    import heapq
    from collections import defaultdict

    def networkDelayTime(self, times, n, k):
        """
        :type times: List[List[int]]
        :type n: int
        :type k: int
        :rtype: int
        """
        #Create adjacency list with weights
        adj = defaultdict(list)
        for u, v, w in times:
            adj[u].append((v, w))

        #Use min heap (priority queue) to store (time, node)
        heap = [(0, k)]
        visited= {}

        while heap:
            time, node = heapq.heappop(heap)
            if node in visited:
                continue
            visited[node] = time
            for nei, wt in adj[node]:
                if nei not in visited:
                    heapq.heappush(heap, (time + wt, nei))

        #Check if all nodes are visited
        if len(visited) == n:
            return max(visited.values())
        return -1

        max_time = max(dist[1:])
        return max_time if max_time != float('inf') else -1
        
#Thoughts(Super-Condensed Summary)
	# 1.	Build an adjacency list from the given edges with weights.
	# 2.	Use a min-heap to always process the node with the smallest signal time.
	# 3.	Track visited nodes with their shortest arrival time using a dictionary.
	# 4.	For each node, push unvisited neighbors into the heap with updated times.
	# 5.	Return the max time from the visited map if all nodes were reached, else -1.
